import 'dart:async';
import 'dart:developer';
import 'dart:io';

import 'package:args/args.dart';
import 'package:path/path.dart' as path;

import 'options.dart';

const languageKeywords = [
  'abstract',
  'else',
  'import',
  'show',
  'as',
  'enum',
  'static',
  'assert',
  'export',
  'interface',
  'super',
  'async',
  'extends',
  'is',
  'switch',
  'await',
  'extension',
  'late',
  'sync',
  'base',
  'external',
  'library',
  'this',
  'break',
  'factory',
  'mixin',
  'throw',
  'case',
  'false',
  'new',
  'true',
  'catch',
  'final',
  'variable',
  'null',
  'try',
  'class',
  'final',
  'class',
  'on',
  'typedef',
  'const',
  'finally',
  'operator',
  'var',
  'continue',
  'for',
  'part',
  'void',
  'covariant',
  'Function',
  'required',
  'when',
  'default',
  'get',
  'rethrow',
  'while',
  'deferred',
  'hide',
  'return',
  'with',
  'do',
  'if',
  'sealed',
  'yield',
  'dynamic',
  'implements',
  'set',
];
void main(List<String> args) {
  if (_isHelpCommand(args)) {
    _printHelperDisplay();
  } else {
    generateSvgData(_generateOption(args));
  }
}

bool _isHelpCommand(List<String> args) {
  return args.length == 1 && (args[0] == '--help' || args[0] == '-h');
}

void _printHelperDisplay() {
  final parser = _generateArgParser(null);
  log(parser.usage);
}

Options _generateOption(List<String> args) {
  final generateOptions = Options();
  _generateArgParser(generateOptions).parse(args);
  return generateOptions;
}

ArgParser _generateArgParser(Options? generateOptions) {
  final parser = ArgParser()
    ..addOption(
      'source-dir',
      abbr: 'S',
      defaultsTo: '/assets/images',
      callback: (String? x) => generateOptions!.sourceDir = x,
      help: 'Folder containing localization files',
    )
    ..addOption(
      'output-dir',
      abbr: 'O',
      defaultsTo: '/lib/generated',
      callback: (String? x) => generateOptions!.outputDir = x,
      help: 'Output folder stores for the generated file',
    )
    ..addOption(
      'name',
      abbr: 'N',
      defaultsTo: 'flowy_svgs.g.dart',
      callback: (String? x) => generateOptions!.outputFile = x,
      help: 'The name of the output file that this tool will generate',
    );

  return parser;
}

/// generates the svg data
Future<void> generateSvgData(Options options) async {
  // the source directory that this is targeting
  final source = Directory(
    [
      Directory.current.path,
      Directory.fromUri(
        Uri.file(
          options.sourceDir!,
          windows: Platform.isWindows,
        ),
      ).path,
    ].join(),
  );

  // the output directory that this is targeting
  final output = File(
    [
      Directory.current.path,
      Directory.fromUri(
        Uri.file(options.outputDir!, windows: Platform.isWindows),
      ).path,
      Platform.pathSeparator,
      File.fromUri(
        Uri.file(
          options.outputFile!,
          windows: Platform.isWindows,
        ),
      ).path,
    ].join(),
  );

  var files = await dirContents(source);
  files = files.where((f) => f.path.contains('.svg')).toList();

  await generate(files, output, options);
}

/// List the contents of the directory
Future<List<FileSystemEntity>> dirContents(Directory dir) {
  final files = <FileSystemEntity>[];
  final completer = Completer<List<FileSystemEntity>>();

  dir.list(recursive: true).listen(
        files.add,
        onDone: () => completer.complete(files),
      );
  return completer.future;
}

/// Generate the abstract class for the FlowySvg data.
Future<void> generate(
  List<FileSystemEntity> files,
  File output,
  Options options,
) async {
  final generated = File(output.path);

  // create the output file if it doesn't exist
  if (!generated.existsSync()) {
    generated.createSync(recursive: true);
  }

  // content of the generated file
  final builder = StringBuffer()..writeln(prelude);
  files.whereType<File>().forEach(
        (element) => builder.writeln(lineFor(element)),
      );
  builder.writeln(postlude);

  generated.writeAsStringSync(builder.toString());
}

String varNameFor(File file) {
  var name = path.basename(file.path).split('.').first.replaceAll('-', '_');
  if (languageKeywords.contains(name)) {
    name = '${name}_';
  } else if (name.startsWith(RegExp('[0-9]'))) {
    name = '\$$name';
  }
  return name;
}

String lineFor(File file) =>
    "  static const ${varNameFor(file)} = FlowySvgData('${pathFor(file)}');";

String pathFor(File file) {
  final relative = path.relative(file.path, from: Directory.current.path);
  final uri = Uri.file(relative);
  return uri.toFilePath(windows: false);
}

/// The prelude for the generated file
const prelude = '''
// DO NOT EDIT. This code is generated by the flowy_svg script

// import the widget with from this package
import 'package:flowy_svg/flowy_svg.dart';

// export as convenience to the programmer
export 'package:flowy_svg/flowy_svg.dart';

/// A class to easily list all the svgs in the app
class FlowySvgs {''';

/// The postlude for the generated file
const postlude = '''
}
''';
